{"ast":null,"code":"import { createSlice, current } from \"@reduxjs/toolkit\";\nimport { isNullOrUndefined } from \"util\";\nimport { canPlayCard } from \"../../BotsServer/BotsServer\";\nimport { wrapMod } from \"../../utils/helpers\";\nlet cardLayoutIdIdx = 111;\n\nfunction generateDrawingCards(cnt) {\n  return Array(cnt).fill(0).map(i => ({\n    layoutId: `id_${cardLayoutIdIdx++}`\n  }));\n}\n\nconst initialState = {\n  tableStack: [],\n  drawingStack: [],\n  inGame: false\n};\nexport const gameSlice = createSlice({\n  name: \"game\",\n  initialState,\n  reducers: {\n    setPlayerId(state, action) {\n      state.playerId = action.payload;\n    },\n\n    init: (state, action) => {\n      const {\n        players,\n        cards: startingCards\n      } = action.payload;\n      state.direction = 1;\n      state.tableStack = [];\n      state.lastPlayerDrawed = false;\n      state.tableStack = [];\n      state.inGame = true; // Find my player and re-order\n\n      let playersFinal = [];\n      let myIdx = 0;\n\n      while (myIdx < players.length) {\n        if (players[myIdx].id === state.playerId) break;\n        myIdx++;\n      }\n\n      for (let i = myIdx; i < players.length; i++) {\n        playersFinal.push(players[i]);\n      }\n\n      state.currentPlayer = playersFinal.length % players.length;\n\n      for (let i = 0; i < myIdx; i++) {\n        playersFinal.push(players[i]);\n      } //Set Cards for players\n\n\n      let cardsToDistribute = startingCards.map(c => ({ ...c,\n        layoutId: `id_${cardLayoutIdIdx++}`,\n        rotationY: 0,\n        playable: myIdx === 0,\n        forPlayer: 0\n      }));\n\n      for (let i = 1; i < playersFinal.length; i++) {\n        cardsToDistribute = cardsToDistribute.concat(Array(startingCards.length).fill(0).map(() => ({\n          layoutId: `id_${cardLayoutIdIdx++}`,\n          forPlayer: i\n        })));\n      }\n\n      state.players = playersFinal;\n      state.drawingStack = cardsToDistribute.concat(generateDrawingCards(20));\n      state.orderOffset = myIdx;\n    },\n\n    ready(state) {\n      state.players = state.players.map((player, idx) => {\n        return { ...player,\n          cards: state.drawingStack.filter(c => c.forPlayer === idx)\n        };\n      });\n      state.drawingStack = state.drawingStack.filter(c => isNullOrUndefined(c.forPlayer));\n    },\n\n    stopGame(state) {\n      state.inGame = false;\n    },\n\n    setInLobby(state, action) {\n      state.inLobby = action.payload;\n    },\n\n    moveCard(state, action) {\n      let {\n        nextPlayer,\n        card,\n        cardsToDraw = [],\n        draw\n      } = action.payload;\n      const curPlayerObj = state.players[state.currentPlayer];\n      nextPlayer = wrapMod(nextPlayer - state.orderOffset, state.players.length);\n      if ((card === null || card === void 0 ? void 0 : card.action) === \"reverse\") state.direction *= -1;\n\n      if (draw) {\n        state.players = state.players.map(p => {\n          if (p.id === curPlayerObj.id) {\n            let newCards = state.drawingStack.slice(0, draw);\n\n            if (curPlayerObj.id === state.playerId && cardsToDraw) {\n              newCards = newCards.map((c, idx) => ({ ...c,\n                ...cardsToDraw[idx],\n                rotationY: 0\n              }));\n            }\n\n            return { ...p,\n              cards: p.cards.concat(newCards)\n            };\n          }\n\n          return p;\n        });\n        state.drawingStack = state.drawingStack.slice(draw).concat(generateDrawingCards(draw));\n        state.lastPlayerDrawed = true;\n      }\n\n      if (card) {\n        let layoutId = \"\";\n        let shouldFlip = false;\n\n        if (curPlayerObj.id !== state.playerId) {\n          layoutId = curPlayerObj.cards[Math.floor(Math.random() * curPlayerObj.cards.length)].layoutId;\n          shouldFlip = true;\n        } else {\n          var _curPlayerObj$cards$f;\n\n          layoutId = (_curPlayerObj$cards$f = curPlayerObj.cards.find(c => c.id === (card === null || card === void 0 ? void 0 : card.id))) === null || _curPlayerObj$cards$f === void 0 ? void 0 : _curPlayerObj$cards$f.layoutId;\n          const cardToMove = curPlayerObj.cards.filter(c => c.layoutId === layoutId)[0];\n          console.log(layoutId, current(cardToMove));\n          card.color = cardToMove.color;\n          card.action = cardToMove.action;\n          card.digit = cardToMove.digit;\n        }\n\n        state.tableStack = [...state.tableStack.slice(-1), {\n          layoutId,\n          color: card.color,\n          action: card.action,\n          digit: card.digit,\n          flip: shouldFlip,\n          rotationY: 0\n        }];\n        state.players = state.players.map(p => {\n          if (p === curPlayerObj) {\n            return { ...p,\n              cards: p.cards.filter(c => c.layoutId !== layoutId)\n            };\n          }\n\n          return p;\n        });\n        state.lastPlayerDrawed = false;\n      }\n\n      state.nextPlayre = nextPlayer;\n    },\n\n    movePlayer(state) {\n      state.players = state.players.map(p => {\n        if (p.id === state.playerId) {\n          const myTurn = state.nextPlayre === 0;\n          return { ...p,\n            cards: p.cards.map(c => {\n              return { ...c,\n                playable: myTurn && canPlayCard(state.tableStack[state.tableStack.length - 1], c, state.lastPlayerDrawed)\n              };\n            })\n          };\n        }\n\n        return p;\n      });\n      state.currentPlayer = state.nextPlayre;\n    }\n\n  }\n});\nexport const {\n  init,\n  ready,\n  stopGame,\n  moveCard,\n  movePlayer,\n  setInLobby,\n  setPlayerId\n} = gameSlice.actions;\nexport default gameSlice.reducer;","map":{"version":3,"sources":["C:/Users/NCC/Desktop/WorkSpace/Task3-ReactJS/src/stores/features/gameSlice.ts"],"names":["createSlice","current","isNullOrUndefined","canPlayCard","wrapMod","cardLayoutIdIdx","generateDrawingCards","cnt","Array","fill","map","i","layoutId","initialState","tableStack","drawingStack","inGame","gameSlice","name","reducers","setPlayerId","state","action","playerId","payload","init","players","cards","startingCards","direction","lastPlayerDrawed","playersFinal","myIdx","length","id","push","currentPlayer","cardsToDistribute","c","rotationY","playable","forPlayer","concat","orderOffset","ready","player","idx","filter","stopGame","setInLobby","inLobby","moveCard","nextPlayer","card","cardsToDraw","draw","curPlayerObj","p","newCards","slice","shouldFlip","Math","floor","random","find","cardToMove","console","log","color","digit","flip","nextPlayre","movePlayer","myTurn","actions","reducer"],"mappings":"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","sourcesContent":["import { createSlice, PayloadAction, current } from \"@reduxjs/toolkit\";\r\nimport { isNullOrUndefined } from \"util\";\r\nimport { canPlayCard } from \"../../BotsServer/BotsServer\";\r\nimport { wrapMod } from \"../../utils/helpers\";\r\nimport { Card, Player } from \"../../utils/interfaces\";\r\n\r\ninterface StoreState {\r\n  playerId: string;\r\n  currentPlayer: number;\r\n  nextPlayre: number;\r\n  orderOffset: number;\r\n  direction: number;\r\n  tableStack: Card[];\r\n  drawingStack: Card[];\r\n  players: Player[];\r\n  lastPlayerDrawed: boolean;\r\n  inGame: boolean;\r\n  inLobby: boolean;\r\n}\r\n\r\nlet cardLayoutIdIdx = 111;\r\n\r\nfunction generateDrawingCards(cnt: number) {\r\n  return Array(cnt)\r\n    .fill(0)\r\n    .map((i) => ({ layoutId: `id_${cardLayoutIdIdx++}` }));\r\n}\r\n\r\nconst initialState = {\r\n  tableStack: [] as Card[],\r\n  drawingStack: [] as Card[],\r\n  inGame: false,\r\n} as StoreState;\r\n\r\nexport const gameSlice = createSlice({\r\n  name: \"game\",\r\n  initialState,\r\n  reducers: {\r\n    setPlayerId(state, action: PayloadAction<string>) {\r\n      state.playerId = action.payload;\r\n    },\r\n    init: (\r\n      state,\r\n      action: PayloadAction<{ players: Player[]; cards: Card[] }>\r\n    ) => {\r\n      const { players, cards: startingCards } = action.payload;\r\n      state.direction = 1;\r\n      state.tableStack = [];\r\n      state.lastPlayerDrawed = false;\r\n      state.tableStack = [];\r\n      state.inGame = true;\r\n\r\n      // Find my player and re-order\r\n      let playersFinal: Player[] = [];\r\n      let myIdx = 0;\r\n      while (myIdx < players.length) {\r\n        if (players[myIdx].id === state.playerId) break;\r\n        myIdx++;\r\n      }\r\n\r\n      for (let i = myIdx; i < players.length; i++) {\r\n        playersFinal.push(players[i]);\r\n      }\r\n      state.currentPlayer = playersFinal.length % players.length;\r\n      for (let i = 0; i < myIdx; i++) {\r\n        playersFinal.push(players[i]);\r\n      }\r\n\r\n      //Set Cards for players\r\n      let cardsToDistribute: Card[] = startingCards.map((c) => ({\r\n        ...c,\r\n        layoutId: `id_${cardLayoutIdIdx++}`,\r\n        rotationY: 0,\r\n        playable: myIdx === 0,\r\n        forPlayer: 0,\r\n      }));\r\n\r\n      for (let i = 1; i < playersFinal.length; i++) {\r\n        cardsToDistribute = cardsToDistribute.concat(\r\n          Array(startingCards.length)\r\n            .fill(0)\r\n            .map(() => ({\r\n              layoutId: `id_${cardLayoutIdIdx++}`,\r\n              forPlayer: i,\r\n            }))\r\n        );\r\n      }\r\n      state.players = playersFinal;\r\n      state.drawingStack = cardsToDistribute.concat(generateDrawingCards(20));\r\n      state.orderOffset = myIdx;\r\n    },\r\n\r\n    ready(state) {\r\n      state.players = state.players.map((player, idx) => {\r\n        return {\r\n          ...player,\r\n          cards: state.drawingStack.filter((c) => c.forPlayer === idx),\r\n        };\r\n      });\r\n\r\n      state.drawingStack = state.drawingStack.filter((c) =>\r\n        isNullOrUndefined(c.forPlayer)\r\n      );\r\n    },\r\n\r\n    stopGame(state) {\r\n      state.inGame = false;\r\n    },\r\n\r\n    setInLobby(state, action: PayloadAction<boolean>) {\r\n      state.inLobby = action.payload;\r\n    },\r\n\r\n    moveCard(\r\n      state,\r\n      action: PayloadAction<{\r\n        nextPlayer: number;\r\n        card?: Card;\r\n        draw?: number;\r\n        cardsToDraw?: Card[];\r\n      }>\r\n    ) {\r\n      let { nextPlayer, card, cardsToDraw = [], draw } = action.payload;\r\n\r\n      const curPlayerObj = state.players[state.currentPlayer];\r\n\r\n      nextPlayer = wrapMod(\r\n        nextPlayer - state.orderOffset,\r\n        state.players.length\r\n      );\r\n\r\n      if (card?.action === \"reverse\") state.direction *= -1;\r\n\r\n      if (draw) {\r\n        state.players = state.players.map((p) => {\r\n          if (p.id === curPlayerObj.id) {\r\n            let newCards = state.drawingStack.slice(0, draw);\r\n            if (curPlayerObj.id === state.playerId && cardsToDraw) {\r\n              newCards = newCards.map((c, idx) => ({\r\n                ...c,\r\n                ...cardsToDraw[idx],\r\n                rotationY: 0,\r\n              }));\r\n            }\r\n            return {\r\n              ...p,\r\n              cards: p.cards.concat(newCards),\r\n            };\r\n          }\r\n          return p;\r\n        });\r\n        state.drawingStack = state.drawingStack\r\n          .slice(draw)\r\n          .concat(generateDrawingCards(draw));\r\n        state.lastPlayerDrawed = true;\r\n      }\r\n\r\n      if (card) {\r\n        let layoutId: string | undefined = \"\";\r\n        let shouldFlip = false;\r\n        if (curPlayerObj.id !== state.playerId) {\r\n          layoutId =\r\n            curPlayerObj.cards[\r\n              Math.floor(Math.random() * curPlayerObj.cards.length)\r\n            ].layoutId;\r\n          shouldFlip = true;\r\n        } else {\r\n          layoutId = curPlayerObj.cards.find((c) => c.id === card?.id)\r\n            ?.layoutId;\r\n          const cardToMove = curPlayerObj.cards.filter(\r\n            (c) => c.layoutId === layoutId\r\n          )[0];\r\n          console.log(layoutId, current(cardToMove));\r\n\r\n          card.color = cardToMove.color;\r\n          card.action = cardToMove.action;\r\n          card.digit = cardToMove.digit;\r\n        }\r\n\r\n        state.tableStack = [\r\n          ...state.tableStack.slice(-1),\r\n          {\r\n            layoutId,\r\n            color: card.color,\r\n            action: card.action,\r\n            digit: card.digit,\r\n            flip: shouldFlip,\r\n            rotationY: 0,\r\n          },\r\n        ];\r\n        state.players = state.players.map((p) => {\r\n          if (p === curPlayerObj) {\r\n            return {\r\n              ...p,\r\n              cards: p.cards.filter((c) => c.layoutId !== layoutId),\r\n            };\r\n          }\r\n          return p;\r\n        });\r\n        state.lastPlayerDrawed = false;\r\n      }\r\n\r\n      state.nextPlayre = nextPlayer;\r\n    },\r\n    movePlayer(state) {\r\n      state.players = state.players.map((p) => {\r\n        if (p.id === state.playerId) {\r\n          const myTurn = state.nextPlayre === 0;\r\n\r\n          return {\r\n            ...p,\r\n            cards: p.cards.map((c) => {\r\n              return {\r\n                ...c,\r\n                playable:\r\n                  myTurn &&\r\n                  canPlayCard(\r\n                    state.tableStack[state.tableStack.length - 1],\r\n                    c,\r\n                    state.lastPlayerDrawed\r\n                  ),\r\n              };\r\n            }),\r\n          };\r\n        }\r\n        return p;\r\n      });\r\n      state.currentPlayer = state.nextPlayre;\r\n    },\r\n  },\r\n});\r\n\r\nexport const {\r\n  init,\r\n  ready,\r\n  stopGame,\r\n  moveCard,\r\n  movePlayer,\r\n  setInLobby,\r\n  setPlayerId,\r\n} = gameSlice.actions;\r\n\r\nexport default gameSlice.reducer;\r\n"]},"metadata":{},"sourceType":"module"}